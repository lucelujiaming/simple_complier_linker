以这句为例：
    char * str1 = "AAA";
首先这句话包含两个符号。
	左值是一个是.data节分配存储空间的初始化全局变量。或者是一个定义在栈上的局部变量。
	右值是在.rdata节分配存储空间的字符串常量。
这句话的处理逻辑如下：
我们首先调用type_specifier读取char发现Type是一个T_CHAR。
之后我们调用declarator，发现了*，我们会把Type改为T_PTR。
之后我们读取左值。之后再读一个符号。这里存在一个技巧。就是：
	如果是等号。说明是赋值操作。需要再读一个符号，把右值也读进来。
	此时，当前的token是右值字符串"AAA"。
之后我们继续处理左值。调用allocate_storage分配空间。
	如果是全局变量。就分配在节上。如果是局部变量，就分配在栈上。
	因为是指针，因此上分配四个字节。
如果没有赋值操作，这里处理就已经结束了。

但是如果存在赋值操作。我们会调用initializer函数。这时，前面的操作就有意义了。
	1. 这个函数的主分支是else部分。首先调用assignment_expression进行表达式分析。
	   因为右值，也有可能是一个表达式。但是我们这里因为是字符串。
	   因此上，在会进入primary_expression中处理。走TK_CSTR分支。
	   整个操作分为三步：
	   1.1. 生成一个字符串指针符号。
	   1.2. 调用allocate_storage分配空间。在这个函数中：	
	    	首先我们调用type_size计算需要分配的存储空间，这里有一个技巧。就是：
	    		如果是字符串"AAA"，他的长度是不固定的。这种情况下返回-1。
	    	之后，allocate_storage发现type_size返回-1.就会使用前面读到的右值计算数据长度。
	    	之后我们就可以利用前面计算出来的长度分配空间了。
	   1.3. 调用var_sym_put把变量放入符号表。
	   1.4. 嵌套调用initializer完成变量初始化。
	        因为前面调用allocate_storage分配空间的时候，是分配的全局空间。
	        因此上，allocate_storage的返回值sec不是空。同时我们强制指定了T_ARRAY类型标志。
	        这导致我们进入initializer函数的if部分。把字符串memcpy到节的指定位置。
	2. 之后，我们调用init_variable完成赋值操作。
	   因为此时右值已经压栈，我们只需要把左值压栈。之后swap左值和右值。
	   之后生成机器码即可。
